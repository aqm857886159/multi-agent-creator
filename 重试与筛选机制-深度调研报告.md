# é‡è¯•ä¸ç­›é€‰æœºåˆ¶ - æ·±åº¦è°ƒç ”æŠ¥å‘Š

**æ—¥æœŸ**: 2025-11-28
**è°ƒç ”èŒƒå›´**: Manus AI, OpenAI, Claude, LangChain, å­¦æœ¯ç ”ç©¶
**ç›®æ ‡**: è®¾è®¡ç”Ÿäº§çº§çš„é‡è¯•é“¾æ¡å’Œæ™ºèƒ½ç­›é€‰æœºåˆ¶

---

## ğŸ“š ä¸šç•Œæœ€ä½³å®è·µè°ƒç ”

### 1. Manus AI çš„æ ¸å¿ƒç†å¿µ

#### ğŸ”‘ "Leave Wrong Turns in Context" (ä¿ç•™é”™è¯¯ä¸Šä¸‹æ–‡)

**æ ¸å¿ƒå‘ç°**:
> "ä¸€ä¸ªå¸¸è§çš„å†²åŠ¨æ˜¯éšè—é”™è¯¯ï¼šæ¸…ç†traceã€é‡è¯•æ“ä½œæˆ–é‡ç½®æ¨¡å‹çŠ¶æ€ã€‚ä½†æ˜¯ï¼Œ**æ“¦é™¤å¤±è´¥ä¼šç§»é™¤è¯æ®ï¼Œè€Œæ²¡æœ‰è¯æ®ï¼Œæ¨¡å‹æ— æ³•é€‚åº”**ã€‚"

**Manusçš„åšæ³•**:
```python
# âŒ ä¼ ç»Ÿåšæ³•: éšè—é”™è¯¯
try:
    result = search(query)
except:
    result = search(fallback_query)  # æ¨¡å‹çœ‹ä¸åˆ°å¤±è´¥

# âœ… Manusåšæ³•: ä¿ç•™é”™è¯¯ä¸Šä¸‹æ–‡
history = []
result = search(query)
history.append({"query": query, "result": result, "success": False})

# è®©æ¨¡å‹çœ‹åˆ°å¤±è´¥ï¼Œè‡ªä¸»å­¦ä¹ 
next_query = model.decide_next_action(history)
```

**å…³é”®æ´å¯Ÿ**:
- å¤±è´¥æ˜¯å®è´µçš„å­¦ä¹ ä¿¡å·
- è®©Agentçœ‹åˆ°"ä¸ºä»€ä¹ˆå¤±è´¥" â†’ é¿å…é‡å¤åŒæ ·çš„é”™è¯¯
- **é”™è¯¯ä¸Šä¸‹æ–‡ = éšå¼çš„ç­–ç•¥è°ƒæ•´**

---

#### ğŸ”§ CodeActæ¶æ„: è‡ªä¿®å¤èƒ½åŠ›

**å®ç°**:
```python
class SelfHealingAgent:
    def execute_with_retry(self, code):
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                return exec(code)
            except Exception as e:
                # ğŸ”‘ å°†é”™è¯¯ä¿¡æ¯ä½œä¸ºè¾“å…¥
                error_analysis = self.llm.analyze_error(code, str(e))
                code = error_analysis.fixed_code  # LLMè‡ªå·±ä¿®å¤ä»£ç 

        return None  # 3æ¬¡å¤±è´¥åæ”¾å¼ƒ
```

**æ ¸å¿ƒæ€æƒ³**:
- **ä¸æ˜¯ç®€å•é‡è¯•ï¼Œè€Œæ˜¯è‡ªä¸»debug**
- LLMçœ‹åˆ°é”™è¯¯æ ˆ â†’ ç†è§£é—®é¢˜ â†’ ç”Ÿæˆä¿®å¤æ–¹æ¡ˆ

---

### 2. OpenAI/Claude çš„é‡è¯•ç­–ç•¥æ¨¡å¼

#### â±ï¸ æŒ‡æ•°é€€é¿ + æŠ–åŠ¨ (Exponential Backoff + Jitter)

**æ ‡å‡†é…ç½®** (æ¥è‡ªTrigger.dev):
```python
retry_config = {
    "maxAttempts": 10,
    "factor": 1.8,           # æŒ‡æ•°å› å­
    "minTimeoutInMs": 500,
    "maxTimeoutInMs": 30000,
    "randomize": True        # ğŸ”‘ æŠ–åŠ¨ï¼Œé¿å…é›·é¸£ç¾Šç¾¤
}
```

**è®¡ç®—å…¬å¼**:
```
delay = min(maxTimeout, minTimeout * factor^attempt) + random_jitter
```

**ç¤ºä¾‹**:
```
Attempt 1: 500ms + jitter
Attempt 2: 900ms + jitter  (500 * 1.8)
Attempt 3: 1620ms + jitter (900 * 1.8)
...
Attempt 10: 30000ms (cap)
```

**ä¸ºä»€ä¹ˆåŠ Jitter?**
- é¿å…å¤šä¸ªè¯·æ±‚åŒæ—¶é‡è¯•ï¼Œé€ æˆ"é›·é¸£ç¾Šç¾¤"æ•ˆåº”
- åˆ†æ•£è´Ÿè½½ï¼Œæé«˜æˆåŠŸç‡

---

#### ğŸ”„ é”™è¯¯åˆ†çº§å¤„ç†

**ä¸šç•Œæ ‡å‡†** (æ¥è‡ªOpenAIæœ€ä½³å®è·µ):

| é”™è¯¯ç±»å‹ | HTTPç  | ç­–ç•¥ | åŸå›  |
|---------|--------|------|------|
| **Rate Limit** | 429 | é€€é¿ + é™çº§åˆ°æ‰¹å¤„ç† | é…é¢è€—å°½ |
| **Server Error** | 5xx | é‡è¯•å¹‚ç­‰è¯»ï¼Œæ°¸ä¸ç›²å†™ | æœåŠ¡å™¨ä¸´æ—¶é—®é¢˜ |
| **Overloaded** | 529 | ç†”æ–­ + åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹ | æœåŠ¡è¿‡è½½ |
| **Bad Request** | 4xx (é429) | **ä¸é‡è¯•**ï¼Œè®°å½•æ—¥å¿— | è¯·æ±‚æœ¬èº«æœ‰é—®é¢˜ |

**å…³é”®å®ç°**:
```python
def should_retry(error_code):
    if error_code == 429:
        return True, "rate_limit"
    elif error_code >= 500:
        return True, "server_error"
    elif error_code in [4xx]:
        return False, "client_error"  # ğŸ”‘ ä¸é‡è¯•å®¢æˆ·ç«¯é”™è¯¯
```

---

#### ğŸ›¡ï¸ ç†”æ–­å™¨æ¨¡å¼ (Circuit Breaker)

**çŠ¶æ€æœº**:
```
[Closed] â†’ [Open] â†’ [Half-Open] â†’ [Closed]
  æ­£å¸¸      ç†”æ–­      è¯•æ¢æ€§æ¢å¤    æ¢å¤
```

**å®ç°**:
```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failures = 0
        self.threshold = failure_threshold
        self.state = "closed"
        self.last_failure_time = None

    def call(self, func):
        if self.state == "open":
            if time.now() - self.last_failure_time > self.timeout:
                self.state = "half-open"  # è¯•æ¢æ€§æ¢å¤
            else:
                raise CircuitOpenError("ç†”æ–­ä¸­ï¼Œæš‚ä¸è¯·æ±‚")

        try:
            result = func()
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

    def on_failure(self):
        self.failures += 1
        if self.failures >= self.threshold:
            self.state = "open"
            self.last_failure_time = time.now()

    def on_success(self):
        self.failures = 0
        self.state = "closed"
```

**ä¸ºä»€ä¹ˆéœ€è¦ç†”æ–­?**
- é˜²æ­¢é›ªå´©ï¼šä¸€ä¸ªæœåŠ¡æŒ‚äº†ï¼Œä¸è¦ç»§ç»­å‘è¯·æ±‚åŠ å‰§é—®é¢˜
- å¿«é€Ÿå¤±è´¥ï¼šç«‹å³è¿”å›é”™è¯¯ï¼Œè€Œéç­‰å¾…è¶…æ—¶
- è‡ªåŠ¨æ¢å¤ï¼šå®šæœŸè¯•æ¢ï¼ŒæœåŠ¡æ¢å¤åè‡ªåŠ¨åˆ‡å›

---

#### ğŸ”€ å¤šProviderå¤‡ä»½ (Multi-Provider Fallback)

**Claude 529é”™è¯¯çš„å¤„ç†** (æ¥è‡ªCursor IDE):
```python
providers = [
    {"name": "Claude", "model": "claude-3-opus"},
    {"name": "OpenAI", "model": "gpt-4"},
    {"name": "Gemini", "model": "gemini-pro"}
]

def call_with_fallback(prompt):
    for provider in providers:
        try:
            return provider.call(prompt)
        except OverloadedError:
            print(f"{provider['name']} è¿‡è½½ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª...")
            continue

    raise AllProvidersFailed()
```

**å…³é”®ä¼˜åŒ–**:
- **100mså†…å®Œæˆåˆ‡æ¢** (ä¿æŒå¯¹è¯æµç•…)
- **ä¸Šä¸‹æ–‡è½¬æ¢**: è°ƒæ•´prompté€‚é…ä¸åŒæ¨¡å‹
- **æˆæœ¬ä¼˜åŒ–**: ä¼˜å…ˆç”¨ä¾¿å®œçš„ï¼Œå¤±è´¥æ‰ç”¨è´µçš„

---

### 3. LLMæœç´¢ç»“æœç­›é€‰ä¸æ’åº

#### ğŸ¯ ä¸¤é˜¶æ®µæ£€ç´¢ (Two-Stage Retrieval)

**æ¶æ„** (æ¥è‡ªLlamaIndex):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åŸå§‹æŸ¥è¯¢            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Stage 1: Embeddingæ£€ç´¢  â”‚  â† å¿«é€Ÿã€ä¾¿å®œ
   â”‚ (å¬å› top-100)          â”‚     å‘é‡ç›¸ä¼¼åº¦
   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Stage 2: LLM Rerank    â”‚  â† ç²¾å‡†ã€è´µ
   â”‚ (é‡æ’ top-10)          â”‚     è¯­ä¹‰ç†è§£
   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
      â”‚ æœ€ç»ˆç»“æœ  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆä¸¤é˜¶æ®µ?**
| é˜¶æ®µ | æ–¹æ³• | æˆæœ¬ | å»¶è¿Ÿ | ç²¾åº¦ |
|------|------|------|------|------|
| Stage 1 | Embedding | $0.0001 | 10ms | 70% |
| Stage 2 | LLM Rerank | $0.01 | 500ms | 95% |

**æœ€ä½³å®è·µ**:
- Stage 1: å¬å›100-200ä¸ªå€™é€‰ (å®å¯å¬å›ç‡é«˜)
- Stage 2: LLMåªçœ‹top 20ï¼Œé‡æ’å‡ºtop 10 (ç²¾å‡†ç‡)

---

#### ğŸ“Š LLM-based AutoCut (è‡ªé€‚åº”æˆªæ–­)

**é—®é¢˜**: ç»™æ¨¡å‹kä¸ªæœç´¢ç»“æœï¼Œä½†å¤šå°‘ä¸ªæ˜¯çœŸæ­£ç›¸å…³çš„ï¼Ÿ

**ä¼ ç»Ÿåšæ³•**: å›ºå®štop-k (å¦‚top-10)

**LLM AutoCut**:
```python
def autocut_with_llm(query, results):
    prompt = f"""
    æŸ¥è¯¢: {query}

    æœç´¢ç»“æœ (å…±{len(results)}ä¸ª):
    {format_results(results)}

    ä»»åŠ¡: åˆ¤æ–­å‰Nä¸ªç»“æœæ˜¯ç›¸å…³çš„ï¼ŒNä¹‹åçš„éƒ½ä¸ç›¸å…³ã€‚
    è¿”å›N (1åˆ°{len(results)}ä¹‹é—´çš„æ•´æ•°)
    """

    N = llm.call(prompt, response_format=int)
    return results[:N]
```

**ä¼˜åŠ¿**:
- **åŠ¨æ€è°ƒæ•´**: é«˜è´¨é‡æŸ¥è¯¢è¿”å›10ä¸ªï¼Œä½è´¨é‡åªè¿”å›2ä¸ª
- **èŠ‚çœæˆæœ¬**: åç»­å¤„ç†åªå¤„ç†ç›¸å…³ç»“æœ
- **æé«˜ç²¾åº¦**: é¿å…å™ªå£°æ±¡æŸ“

---

#### ğŸ” ç›¸å…³æ€§è¯„åˆ† (Relevance Scoring)

**LLMè¯„åˆ†ç³»ç»Ÿ** (æ¥è‡ªWeaviate):
```python
def llm_score_relevance(query, result):
    prompt = f"""
    æŸ¥è¯¢: {query}
    ç»“æœæ ‡é¢˜: {result.title}
    ç»“æœæ‘˜è¦: {result.summary}

    è¯„åˆ† (0-10):
    - 0: å®Œå…¨ä¸ç›¸å…³
    - 5: éƒ¨åˆ†ç›¸å…³
    - 10: å®Œç¾åŒ¹é…

    åªè¿”å›æ•°å­—ã€‚
    """

    score = llm.call(prompt, response_format=int)
    return score
```

**æ‰¹é‡è¯„åˆ†** (èŠ‚çœæˆæœ¬):
```python
prompt = f"""
æŸ¥è¯¢: {query}

æ‰¹é‡è¯„åˆ†ä»¥ä¸‹10ä¸ªç»“æœ (è¿”å›JSON):
1. {result1.title}
2. {result2.title}
...

è¿”å›: {{"scores": [8, 3, 9, ...]}}
"""
```

**é˜ˆå€¼ç­–ç•¥**:
```python
# æ–¹æ¡ˆ1: å›ºå®šé˜ˆå€¼
relevant = [r for r, score in results if score >= 7]

# æ–¹æ¡ˆ2: ç›¸å¯¹é˜ˆå€¼ (ä¿è¯è‡³å°‘Kä¸ª)
sorted_results = sorted(results, key=lambda x: x.score, reverse=True)
top_score = sorted_results[0].score
relevant = [r for r in sorted_results if r.score >= top_score * 0.7]
```

---

### 4. å¤šæ™ºèƒ½ä½“ç³»ç»Ÿçš„åé¦ˆå¾ªç¯è®¾è®¡

#### ğŸ”„ Critic-Refineræ¨¡å¼ (è¯„è®º-æ”¹è¿›)

**æ¶æ„** (æ¥è‡ªn8n workflow):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generatorâ”‚ â†’ ç”Ÿæˆåˆå§‹ç»“æœ
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚
  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
  â”‚ Critic â”‚ â†’ è¯„ä¼°è´¨é‡ï¼ŒæŒ‡å‡ºé—®é¢˜
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚
  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
  â”‚ Refinerâ”‚ â†’ æ ¹æ®æ‰¹è¯„æ”¹è¿›
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚
  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
  â”‚Evaluator â”‚ â†’ åˆ¤æ–­æ˜¯å¦è¾¾æ ‡
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚
    [å¾ªç¯ or å®Œæˆ]
```

**å®ç°**:
```python
class CriticRefinerLoop:
    def __init__(self, max_iterations=3):
        self.max_iterations = max_iterations

    def improve(self, initial_output, quality_threshold=8):
        output = initial_output

        for i in range(self.max_iterations):
            # Critic: è¯„ä¼°
            critique = self.critic.analyze(output)
            score = critique.score

            if score >= quality_threshold:
                return output, "è¾¾æ ‡"

            # Refiner: æ”¹è¿›
            output = self.refiner.improve(output, critique.issues)

            # ğŸ”‘ ä¿ç•™æ”¹è¿›å†å²
            self.history.append({
                "iteration": i,
                "critique": critique,
                "output": output
            })

        return output, "æœªè¾¾æ ‡ï¼Œå·²è¾¾æœ€å¤§è¿­ä»£æ¬¡æ•°"
```

**å…³é”®è®¾è®¡**:
- **æ˜¾å¼è´¨é‡é˜ˆå€¼**: ä¸æ˜¯è¿­ä»£å›ºå®šæ¬¡æ•°ï¼Œè€Œæ˜¯è¾¾åˆ°è´¨é‡æ ‡å‡†
- **ä¿ç•™æ”¹è¿›å†å²**: è®©åç»­è¿­ä»£çœ‹åˆ°ä¹‹å‰çš„å°è¯•
- **é˜²æ­¢æ— é™å¾ªç¯**: max_iterationsä½œä¸ºæŠ¤æ 

---

#### ğŸ“ Quality Gate with Scale Gates

**ä¼ä¸šçº§å®è·µ** (æ¥è‡ª2025 Agentic AI Trends):

**Scale Gateç­–ç•¥**:
```
Gate 1 (POC): åŠŸèƒ½å¯ç”¨æ€§ â†’ é€šè¿‡/è¿­ä»£
Gate 2 (Pilot): â‰¥15% KPIæå‡ â†’ ç»§ç»­/åœæ­¢
Gate 3 (Scale): â‰¥30% KPIæå‡ â†’ è§„æ¨¡åŒ–/é‡æ–°è®¾è®¡
```

**åœ¨æœç´¢ç³»ç»Ÿçš„åº”ç”¨**:
```python
class QualityGate:
    def __init__(self):
        self.gates = {
            "gate1_functional": 0.5,    # è‡³å°‘50%ç»“æœå¯ç”¨
            "gate2_relevant": 0.7,      # è‡³å°‘70%ç›¸å…³
            "gate3_excellent": 0.85     # 85%é«˜è´¨é‡
        }

    def evaluate(self, results):
        usable_rate = count_usable(results) / len(results)
        relevant_rate = count_relevant(results) / len(results)

        if usable_rate < self.gates["gate1_functional"]:
            return "FAIL", "åŠŸèƒ½æ€§å¤±è´¥ï¼Œåœæ­¢"
        elif relevant_rate < self.gates["gate2_relevant"]:
            return "ITERATE", "éœ€è¦æ”¹è¿›æŸ¥è¯¢"
        elif relevant_rate >= self.gates["gate3_excellent"]:
            return "SCALE", "è´¨é‡ä¼˜ç§€ï¼Œå¯ç»§ç»­"
        else:
            return "PASS", "å¯æ¥å—"
```

---

#### ğŸ§  Human-in-the-Loop (HITL)

**ä¿¡ä»»æ„å»ºçš„æ ¸å¿ƒ** (æ¥è‡ªDIS 2025ç ”ç©¶):

**å…³é”®å‘ç°**:
> "æœ‰æ•ˆçš„ä¿¡ä»»æ„å»ºç­–ç•¥åŒ…æ‹¬é›†æˆhuman-in-the-loopè®¾è®¡ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿä¸»åŠ¨å¼•å¯¼AIè¡Œä¸ºå¹¶æä¾›åé¦ˆã€‚"

**å®ç°æ–¹å¼**:

```python
# æ–¹æ¡ˆ1: ç¡®è®¤å¼HITL (é«˜ç½®ä¿¡åº¦è·³è¿‡)
if confidence < 0.8:
    user_feedback = ask_user("æ˜¯å¦ä½¿ç”¨è¿™ä¸ªæœç´¢ç»“æœ?")
    if not user_feedback.approved:
        retry_with_different_query()

# æ–¹æ¡ˆ2: ä¸»åŠ¨å­¦ä¹ å¼HITL (é€‰æ‹©æœ€æœ‰ä»·å€¼çš„æ ·æœ¬)
uncertain_samples = [s for s in samples if 0.4 < s.confidence < 0.6]
if uncertain_samples:
    labeled = ask_user_to_label(uncertain_samples[:5])
    model.update(labeled)

# æ–¹æ¡ˆ3: æ‰¹å‡†å¼HITL (äº‹åå®¡æ ¸)
results = agent.search()
if requires_approval(results):
    wait_for_approval()  # å¼‚æ­¥ï¼Œä¸é˜»å¡å…¶ä»–ä»»åŠ¡
```

---

## ğŸ¯ å½“å‰ç³»ç»Ÿé—®é¢˜è¯Šæ–­

### é—®é¢˜1: é‡è¯•é“¾æ¡ç¼ºå¤±

**ç°çŠ¶**:
```
æœç´¢ â†’ è´¨é‡æ£€æŸ¥ â†’ è¿”å›"adjust_params" â†’ âŒ Plannerå¿½ç•¥ â†’ ç»§ç»­
```

**åº”è¯¥æ˜¯**:
```
æœç´¢ â†’ è´¨é‡æ£€æŸ¥ â†’ è§¦å‘é‡è¯• â†’ é™çº§æŸ¥è¯¢ â†’ å†æ¬¡æœç´¢ â†’ è´¨é‡æ£€æŸ¥ â†’ ...
       â†‘______________|  (æœ€å¤š3æ¬¡)
```

**ç¼ºå°‘çš„ç¯èŠ‚**:
1. âœ… è´¨é‡æ£€æŸ¥ (å·²æœ‰)
2. âŒ **é‡è¯•å†³ç­–é€»è¾‘** (ç¼ºå¤±)
3. âŒ **é™çº§ç­–ç•¥æ‰§è¡Œ** (è™½ç„¶æœ‰layered_keywordï¼Œä½†æœªé›†æˆ)
4. âŒ **ç†”æ–­æœºåˆ¶** (é˜²æ­¢æ— é™é‡è¯•)

---

### é—®é¢˜2: ç­›é€‰è¿‡æ»¤è¿‡åº¦

**æ—¥å¿—è¯æ®**:
```
Bç«™æ‰¾åˆ°:
- "Manusåˆ›å§‹äººï¼šæ·±åº¦å¹²è´§" âœ…
- "ä¸ºä»€ä¹ˆManusåšé€šç”¨æ™ºèƒ½ä½“æ³¨å®šå¤±è´¥" âœ…
- "LangChainä¸Manusçš„AIæ™ºèƒ½ä½“" âœ…

ä½†Architectè®¡ç®—ç›¸å…³æ€§: 0% âŒ
```

**åŸå› åˆ†æ**:

**å¯èƒ½åŸå› 1**: Filterè¿‡æ»¤æ‰äº†ç›¸å…³ç»“æœ
```
56æ¡ â†’ Filter â†’ 10æ¡
```
åªæœ‰10æ¡è¿›å…¥Architectï¼Œå¯èƒ½Manusè§†é¢‘åœ¨46æ¡"åƒåœ¾"ä¸­

**å¯èƒ½åŸå› 2**: Architectè®¡ç®—é€»è¾‘é—®é¢˜
```python
# å½“å‰é€»è¾‘ (çŒœæµ‹)
matched = sum(1 for r in results if "manus" in r.title.lower())
relevance = matched / len(results)  # 3/10 = 30%

# ä½†å¦‚æœManusè§†é¢‘è¢«Filterè¿‡æ»¤ï¼ŒArchitectåªçœ‹åˆ°åƒåœ¾
# â†’ matched = 0, relevance = 0%
```

---

### é—®é¢˜3: ç¼ºå°‘æ™ºèƒ½é¢„ç­›é€‰

**å½“å‰æµç¨‹**:
```
æ”¶é›†56æ¡ â†’ ç¡¬è§„åˆ™Filter (æ—¶æ•ˆã€æ’­æ”¾é‡) â†’ 10æ¡ â†’ Architect
```

**é—®é¢˜**:
- Filteråªçœ‹æ•°å€¼æŒ‡æ ‡ (æ’­æ”¾é‡ã€æ—¶é—´)
- ä¸çœ‹è¯­ä¹‰ç›¸å…³æ€§
- **å¯èƒ½è¿‡æ»¤æ‰ä½æ’­æ”¾ä½†é«˜ç›¸å…³çš„ç»“æœ**

**ä¸šç•Œåšæ³•** (ä¸¤é˜¶æ®µ):
```
æ”¶é›†56æ¡ â†’ LLMé¢„ç­›é€‰ (ç›¸å…³æ€§) â†’ 20æ¡ â†’ ç¡¬è§„åˆ™Filter â†’ 10æ¡ â†’ Architect
```

---

## ğŸ’¡ è§£å†³æ–¹æ¡ˆè®¾è®¡

### æ–¹æ¡ˆA: å®Œæ•´é‡è¯•é“¾æ¡ (å¿…é¡»å®æ–½)

#### æ¶æ„è®¾è®¡

```python
class RetryChain:
    """
    å®Œæ•´çš„é‡è¯•é“¾æ¡

    ç‰¹æ€§:
    1. ä¿ç•™é”™è¯¯ä¸Šä¸‹æ–‡ (Manusç†å¿µ)
    2. åˆ†å±‚é™çº§ç­–ç•¥ (Layer 1â†’2â†’3)
    3. ç†”æ–­ä¿æŠ¤ (æœ€å¤š3æ¬¡)
    4. é”™è¯¯ç±»å‹åˆ¤æ–­ (å¯é‡è¯• vs ä¸å¯é‡è¯•)
    """

    def __init__(self):
        self.max_retries = 3
        self.retry_history = []
        self.circuit_breaker = CircuitBreaker(threshold=5)

    def execute_with_retry(self, query, search_func):
        # ç”Ÿæˆåˆ†å±‚æŸ¥è¯¢
        fallback_layers = generate_fallback_keywords(query)
        all_queries = [
            query,  # åŸå§‹æŸ¥è¯¢
            *fallback_layers["layer1_precise"],
            *fallback_layers["layer2_functional"][:2],
            fallback_layers["layer3_generic"][0]
        ]

        for attempt, current_query in enumerate(all_queries[:self.max_retries]):
            # ğŸ”‘ æ£€æŸ¥ç†”æ–­å™¨
            if self.circuit_breaker.is_open():
                return self._create_failure_result("ç†”æ–­ä¸­")

            try:
                # æ‰§è¡Œæœç´¢
                results = search_func(current_query)

                # è´¨é‡éªŒè¯
                validation = validate_search_results(current_query, results)

                if validation["is_valid"]:
                    # æˆåŠŸï¼
                    self.circuit_breaker.on_success()
                    return self._create_success_result(results, attempt)

                # å¤±è´¥ï¼Œä½†å¯é‡è¯•
                self._log_failure(attempt, current_query, validation)

                # ğŸ”‘ ä¿ç•™é”™è¯¯ä¸Šä¸‹æ–‡ (Manusç†å¿µ)
                self.retry_history.append({
                    "attempt": attempt,
                    "query": current_query,
                    "validation": validation,
                    "reason": validation["issues"]
                })

                print(f"""
ğŸ”„ é‡è¯• {attempt+1}/{self.max_retries}
   åŸæŸ¥è¯¢: {query}
   å½“å‰å°è¯•: {current_query}
   å¤±è´¥åŸå› : {validation['issues']}
   ä¸‹ä¸€æ­¥: {all_queries[attempt+1] if attempt+1 < len(all_queries) else 'æ”¾å¼ƒ'}
                """)

            except Exception as e:
                self.circuit_breaker.on_failure()
                if not self._is_retryable_error(e):
                    # å®¢æˆ·ç«¯é”™è¯¯ï¼Œä¸é‡è¯•
                    return self._create_failure_result(f"ä¸å¯é‡è¯•é”™è¯¯: {e}")

        # æ‰€æœ‰é‡è¯•å¤±è´¥
        return self._create_exhausted_result()

    def _create_failure_result(self, reason):
        return {
            "success": False,
            "reason": reason,
            "retry_history": self.retry_history,
            "suggestions": self._generate_user_suggestions()
        }

    def _generate_user_suggestions(self):
        """åŸºäºé‡è¯•å†å²ç”Ÿæˆç”¨æˆ·å»ºè®®"""
        if len(self.retry_history) >= 3:
            # æ‰€æœ‰å±‚çº§éƒ½è¯•è¿‡äº†
            return [
                "è¯¥ä¸»é¢˜å¯èƒ½æ•°æ®ä¸è¶³ï¼ˆæ–°å…¬å¸/å°ä¼—äº§å“ï¼‰",
                "å»ºè®®æ£€æŸ¥æ‹¼å†™",
                f"å·²å°è¯•: {[h['query'] for h in self.retry_history]}"
            ]
        else:
            return ["ç³»ç»Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•"]
```

---

### æ–¹æ¡ˆB: æ™ºèƒ½é¢„ç­›é€‰ (æ¨èå®æ–½)

#### LLM-Based Two-Stage Filtering

```python
class TwoStageFilter:
    """
    ä¸¤é˜¶æ®µç­›é€‰:
    Stage 1: LLMè¯­ä¹‰ç­›é€‰ (ç›¸å…³æ€§)
    Stage 2: ç¡¬è§„åˆ™ç­›é€‰ (æ’­æ”¾é‡ã€æ—¶æ•ˆ)
    """

    def filter(self, query, raw_results, target_count=10):
        # Stage 1: LLMæ‰¹é‡è¯„åˆ† (å¿«é€Ÿ)
        print(f"ğŸ“Š Stage 1: LLMè¯­ä¹‰ç­›é€‰ (from {len(raw_results)} results)")

        scored_results = self._batch_score_relevance(query, raw_results)

        # è‡ªé€‚åº”é˜ˆå€¼: ä¿è¯è‡³å°‘æœ‰target_count * 2ä¸ªå€™é€‰
        sorted_by_score = sorted(scored_results, key=lambda x: x['score'], reverse=True)
        top_score = sorted_by_score[0]['score']
        threshold = max(top_score * 0.6, 5)  # è‡³å°‘5åˆ† æˆ– topåˆ†çš„60%

        stage1_passed = [r for r in sorted_by_score if r['score'] >= threshold]
        stage1_passed = stage1_passed[:target_count * 2]  # æœ€å¤šä¿ç•™20ä¸ª

        print(f"   âœ… é€šè¿‡ {len(stage1_passed)}/{len(raw_results)} (é˜ˆå€¼: {threshold})")

        # Stage 2: ç¡¬è§„åˆ™ç­›é€‰
        print(f"ğŸ“Š Stage 2: ç¡¬è§„åˆ™ç­›é€‰ (æ’­æ”¾é‡ã€æ—¶æ•ˆ)")

        stage2_passed = self._apply_hard_rules(stage1_passed)

        print(f"   âœ… æœ€ç»ˆ: {len(stage2_passed)} æ¡")

        return stage2_passed[:target_count]

    def _batch_score_relevance(self, query, results):
        """
        æ‰¹é‡è¯„åˆ† (1æ¬¡LLMè°ƒç”¨å¤„ç†10-20ä¸ªç»“æœ)
        """
        batch_size = 20
        all_scored = []

        for i in range(0, len(results), batch_size):
            batch = results[i:i+batch_size]

            # æ„å»ºæ‰¹é‡æç¤º
            formatted_results = "\n".join([
                f"{j+1}. {r['title']}"
                for j, r in enumerate(batch)
            ])

            prompt = f"""
æŸ¥è¯¢: {query}

æ‰¹é‡è¯„åˆ†ä»¥ä¸‹ç»“æœçš„ç›¸å…³æ€§ (0-10åˆ†):
{formatted_results}

è¿”å›JSON: {{"scores": [8, 3, 9, ...]}}
åªè¿”å›åˆ†æ•°åˆ—è¡¨ï¼Œä¸è¦è§£é‡Šã€‚
            """

            try:
                response = self.llm.call(prompt, response_format="json")
                scores = json.loads(response)["scores"]

                for r, score in zip(batch, scores):
                    r['relevance_score'] = score
                    all_scored.append(r)

            except Exception as e:
                print(f"âš ï¸ æ‰¹é‡è¯„åˆ†å¤±è´¥: {e}ï¼Œä½¿ç”¨é»˜è®¤åˆ†æ•°")
                for r in batch:
                    r['relevance_score'] = 5  # é»˜è®¤ä¸­ç­‰
                    all_scored.append(r)

        return all_scored

    def _apply_hard_rules(self, results):
        """
        ç¡¬è§„åˆ™ç­›é€‰:
        - æ—¶æ•ˆæ€§
        - æ’­æ”¾é‡
        - äº’åŠ¨ç‡
        """
        filtered = []

        for r in results:
            # è§„åˆ™1: æ—¶æ•ˆæ€§ (60å¤©å†…)
            if not self._check_recency(r, days=60):
                continue

            # è§„åˆ™2: æ’­æ”¾é‡ (æ ¹æ®ä¸­ä½æ•°)
            median_views = self._get_median_views(results)
            if r['view_count'] < median_views * 0.3:  # ä½äºä¸­ä½æ•°30%
                continue

            filtered.append(r)

        return filtered
```

**å…³é”®ä¼˜åŠ¿**:
1. **ç›¸å…³æ€§ä¼˜å…ˆ**: å…ˆçœ‹æ˜¯å¦ç›¸å…³ï¼Œå†çœ‹æ’­æ”¾é‡
2. **æ‰¹é‡è¯„åˆ†**: 1æ¬¡LLMè°ƒç”¨å¤„ç†20ä¸ªï¼Œæˆæœ¬ä½
3. **è‡ªé€‚åº”é˜ˆå€¼**: æ ¹æ®å®é™…ç»“æœåŠ¨æ€è°ƒæ•´
4. **ä¿ç•™é«˜ç›¸å…³ä½æ’­æ”¾**: ä¸ä¼šé”™è¿‡"Manusåˆ›å§‹äºº"è¿™ç±»è§†é¢‘

---

### æ–¹æ¡ˆC: Critic-Refiner for Search Query

#### è®©LLMè‡ªå·±ä¼˜åŒ–æŸ¥è¯¢

```python
class QueryRefiner:
    """
    æŸ¥è¯¢ä¼˜åŒ–åé¦ˆå¾ªç¯:
    1. æ‰§è¡Œæœç´¢
    2. Criticè¯„ä¼°ç»“æœè´¨é‡
    3. Refinerç”Ÿæˆæ”¹è¿›æŸ¥è¯¢
    4. é‡å¤ (æœ€å¤š3æ¬¡)
    """

    def refine_query(self, original_query, max_iterations=3):
        query = original_query

        for iteration in range(max_iterations):
            # æ‰§è¡Œæœç´¢
            results = search(query)

            # Critic: è¯„ä¼°ç»“æœ
            critique = self.critic_llm.call(f"""
åŸå§‹æŸ¥è¯¢: {original_query}
å½“å‰æŸ¥è¯¢: {query}

æœç´¢ç»“æœ:
{format_results(results[:10])}

è¯„ä¼°:
1. ç›¸å…³æ€§ (0-10): ?
2. é—®é¢˜è¯Šæ–­: ?
3. å»ºè®®æ”¹è¿›æ–¹å‘: ?

è¿”å›JSONæ ¼å¼ã€‚
            """)

            if critique["relevance_score"] >= 8:
                return query, results, "æˆåŠŸ"

            # Refiner: ç”Ÿæˆæ”¹è¿›æŸ¥è¯¢
            refined_query = self.refiner_llm.call(f"""
åŸæŸ¥è¯¢: {original_query}
å½“å‰æŸ¥è¯¢: {query}
é—®é¢˜: {critique["issues"]}
å»ºè®®: {critique["suggestions"]}

ç”Ÿæˆ1ä¸ªæ”¹è¿›çš„æŸ¥è¯¢ (æ›´ç®€æ´/æ›´ç²¾å‡†)ã€‚
åªè¿”å›æŸ¥è¯¢æ–‡æœ¬ã€‚
            """)

            print(f"""
ğŸ”„ Queryè¿­ä»£ {iteration+1}
   å½“å‰: {query}
   è¯„åˆ†: {critique['relevance_score']}/10
   æ”¹è¿›: {refined_query}
            """)

            query = refined_query

        return query, results, "æœªè¾¾æ ‡"
```

---

## ğŸ—ï¸ æ¨èå®æ–½æ–¹æ¡ˆ

### é˜¶æ®µ1: åŸºç¡€é‡è¯•é“¾æ¡ (ä¼˜å…ˆçº§: P0)

**å®æ–½**:
1. ä¿®æ”¹ `nodes/planner.py` æˆ– `nodes/executor.py`
2. é›†æˆ `RetryChain` ç±»
3. è¿æ¥ `layered_keyword_strategy.py` (å·²å®Œæˆ)

**é¢„æœŸæ•ˆæœ**:
- è‡ªåŠ¨é™çº§: `Manus AI success` â†’ `"Manus"` â†’ `Manus tutorial`
- ç†”æ–­ä¿æŠ¤: æœ€å¤š3æ¬¡é‡è¯•
- æ¸…æ™°åé¦ˆ: "å·²å°è¯•Xä¸ªæŸ¥è¯¢ï¼Œå‡å¤±è´¥"

---

### é˜¶æ®µ2: æ™ºèƒ½é¢„ç­›é€‰ (ä¼˜å…ˆçº§: P1)

**å®æ–½**:
1. åœ¨ `nodes/filter.py` ä¹‹å‰æ’å…¥ `TwoStageFilter`
2. Stage 1: LLMæ‰¹é‡è¯„åˆ†
3. Stage 2: ç°æœ‰ç¡¬è§„åˆ™

**é¢„æœŸæ•ˆæœ**:
- ä¸å†é”™è¿‡"Manusåˆ›å§‹äºº"è¿™ç±»é«˜ç›¸å…³ä½†ä½æ’­æ”¾çš„è§†é¢‘
- æˆæœ¬å¢åŠ : ~$0.01/æŸ¥è¯¢ (æ‰¹é‡è¯„åˆ†)
- ç²¾åº¦æå‡: 70% â†’ 90%+

---

### é˜¶æ®µ3: Query Refiner (ä¼˜å…ˆçº§: P2, å¯é€‰)

**å®æ–½**:
1. åˆ›å»º `QueryRefiner` ç±»
2. é›†æˆåˆ°Plannerä½œä¸ºé«˜çº§é‡è¯•ç­–ç•¥

**é¢„æœŸæ•ˆæœ**:
- LLMè‡ªä¸»å­¦ä¹ ä¼˜åŒ–æŸ¥è¯¢
- é€‚åº”ä¸åŒå¹³å°ç‰¹æ€§
- æˆæœ¬è¾ƒé«˜: ~$0.05/æŸ¥è¯¢ (3æ¬¡è¿­ä»£)

---

## ğŸ“Š æˆæœ¬-æ•ˆæœåˆ†æ

| æ–¹æ¡ˆ | æˆæœ¬/æŸ¥è¯¢ | å»¶è¿Ÿ | ç²¾åº¦æå‡ | å¤æ‚åº¦ |
|------|----------|------|---------|--------|
| **ä»…é‡è¯•é“¾æ¡** | +$0.005 | +500ms | +20% | ä½ |
| **+æ™ºèƒ½é¢„ç­›é€‰** | +$0.015 | +1s | +40% | ä¸­ |
| **+Query Refiner** | +$0.050 | +3s | +50% | é«˜ |

**æ¨è**: é˜¶æ®µ1 + é˜¶æ®µ2

---

## ğŸ¯ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **ç«‹å³**: å®æ–½RetryChain (2å°æ—¶)
2. **ä»Šå¤©**: å®æ–½TwoStageFilter (3å°æ—¶)
3. **æ˜å¤©**: é›†æˆæµ‹è¯• + è°ƒä¼˜é˜ˆå€¼

æœŸå¾…æ‚¨çš„åé¦ˆï¼
