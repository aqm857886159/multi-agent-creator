# è‡ªé€‚åº”åé¦ˆå¾ªç¯ç³»ç»Ÿè®¾è®¡ (Adaptive Feedback Loop System)

## ğŸ¯ æ ¸å¿ƒç†å¿µ

**è®©ç³»ç»Ÿåƒäººä¸€æ ·æ€è€ƒ**ï¼š
- æ¯å®Œæˆä¸€ä¸ªæ­¥éª¤ï¼Œéƒ½è¦**è‡ªæˆ‘æ£€æŸ¥**
- å‘ç°é—®é¢˜ç«‹å³**åé¦ˆè°ƒæ•´**
- ä½¿ç”¨**å¿«é€Ÿæ¨¡å‹**åˆ¤æ–­ï¼ˆé™ä½æˆæœ¬ï¼‰
- è®¾ç½®**æ­»å¾ªç¯ä¿æŠ¤**ï¼ˆæœ€å¤šé‡è¯•Næ¬¡ï¼‰

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 1: Planning                                  â”‚
â”‚  â”œâ”€ Keyword Designer â†’ Generate Queries             â”‚
â”‚  â””â”€ âœ… Self-Check: Are queries diverse enough?      â”‚
â”‚     â””â”€ âŒ No â†’ Regenerate with feedback             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 2: Execution                                 â”‚
â”‚  â”œâ”€ Execute Tool (e.g., youtube_search)             â”‚
â”‚  â””â”€ âœ… Quality Gate: Is result relevant?            â”‚
â”‚     â”œâ”€ âŒ No â†’ Adjust query & retry                 â”‚
â”‚     â””â”€ âœ… Yes â†’ Continue                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 3: Aggregation Check                         â”‚
â”‚  â”œâ”€ Check total collected items                     â”‚
â”‚  â””â”€ âœ… Quantity Gate: Is data sufficient?           â”‚
â”‚     â”œâ”€ âŒ No â†’ Add more tasks                       â”‚
â”‚     â””â”€ âœ… Yes â†’ Continue                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 4: Balance Check                             â”‚
â”‚  â”œâ”€ Check platform distribution                     â”‚
â”‚  â””â”€ âœ… Balance Gate: Is distribution balanced?      â”‚
â”‚     â”œâ”€ âŒ No â†’è¡¥å……å¼±åŠ¿å¹³å°æ•°æ®                       â”‚
â”‚     â””â”€ âœ… Yes â†’ Continue to Filter                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 5: Filter & Output                           â”‚
â”‚  â”œâ”€ Smart Filter                                    â”‚
â”‚  â””â”€ âœ… Quality Gate: Is final output quality high?  â”‚
â”‚     â”œâ”€ âŒ No â†’ Loosen filter & retry                â”‚
â”‚     â””â”€ âœ… Yes â†’ Generate Briefs                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶

### 1. Quality Gate (è´¨é‡é—¨)

**åŠŸèƒ½**: æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œåè‡ªåŠ¨æ£€æŸ¥ç»“æœè´¨é‡

**å®ç°**:
```python
# core/quality_gate.py

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from core.llm import get_llm_with_schema

class QualityCheckResult(BaseModel):
    """è´¨é‡æ£€æŸ¥ç»“æœ"""
    passed: bool = Field(..., description="æ˜¯å¦é€šè¿‡è´¨é‡æ£€æŸ¥")
    score: float = Field(..., description="è´¨é‡åˆ†æ•° 0-1")
    issues: List[str] = Field(default_factory=list, description="å‘ç°çš„é—®é¢˜åˆ—è¡¨")
    suggestions: List[str] = Field(default_factory=list, description="æ”¹è¿›å»ºè®®")
    action: Optional[str] = Field(None, description="å»ºè®®çš„è¡ŒåŠ¨: retry/adjust/continue")

class QualityGate:
    """è´¨é‡é—¨ï¼šè‡ªåŠ¨æ£€æŸ¥ç»“æœè´¨é‡"""

    @staticmethod
    def check_search_result(
        query: str,
        results: List[Dict],
        expectation: str,
        min_items: int = 10
    ) -> QualityCheckResult:
        """
        æ£€æŸ¥æœç´¢ç»“æœè´¨é‡

        Args:
            query: æœç´¢è¯
            results: æœç´¢ç»“æœåˆ—è¡¨
            expectation: æœŸæœ›çš„å†…å®¹ç±»å‹
            min_items: æœ€å°‘æœŸæœ›çš„ç»“æœæ•°

        Returns:
            QualityCheckResult
        """
        if not results:
            return QualityCheckResult(
                passed=False,
                score=0.0,
                issues=["æœç´¢ç»“æœä¸ºç©º"],
                suggestions=["æ£€æŸ¥æœç´¢è¯æ˜¯å¦è¿‡äºå…·ä½“", "å°è¯•ä½¿ç”¨æ›´é€šç”¨çš„å…³é”®è¯"],
                action="retry"
            )

        if len(results) < min_items:
            return QualityCheckResult(
                passed=False,
                score=len(results) / min_items,
                issues=[f"ç»“æœæ•°é‡ä¸è¶³ï¼ˆ{len(results)}/{min_items}ï¼‰"],
                suggestions=["æ”¾å®½æœç´¢æ¡ä»¶", "å¢åŠ æŠ“å–æ•°é‡"],
                action="adjust"
            )

        # ä½¿ç”¨å¿«é€Ÿæ¨¡å‹æ£€æŸ¥ç›¸å…³æ€§
        sample_titles = [r.get('title', '') for r in results[:10]]

        prompt = f"""
        æœç´¢è¯: {query}
        æœŸæœ›å†…å®¹: {expectation}

        å®é™…è¿”å›çš„æ ‡é¢˜ç¤ºä¾‹ï¼ˆå‰10æ¡ï¼‰:
        {chr(10).join(f"{i+1}. {t}" for i, t in enumerate(sample_titles))}

        å¿«é€Ÿåˆ¤æ–­ï¼šè¿™äº›ç»“æœä¸æœŸæœ›å†…å®¹çš„ç›¸å…³æ€§å¦‚ä½•ï¼Ÿ

        è¯„åˆ†æ ‡å‡†:
        - 0.8-1.0: é«˜åº¦ç›¸å…³ï¼Œå¤§éƒ¨åˆ†ç»“æœç¬¦åˆæœŸæœ›
        - 0.5-0.8: ä¸­åº¦ç›¸å…³ï¼Œéƒ¨åˆ†ç»“æœç¬¦åˆ
        - 0.3-0.5: ä½åº¦ç›¸å…³ï¼Œå°‘é‡ç»“æœç¬¦åˆ
        - 0.0-0.3: å‡ ä¹ä¸ç›¸å…³

        å¦‚æœç›¸å…³æ€§ä½ï¼Œåˆ†æå¯èƒ½çš„åŸå› ï¼ˆå¦‚å…³é”®è¯é™·é˜±ã€å¹³å°ç‰¹æ€§ç­‰ï¼‰ã€‚
        """

        try:
            check_result: QualityCheckResult = get_llm_with_schema(
                user_prompt=prompt,
                response_model=QualityCheckResult,
                capability="fast",  # ğŸ”‘ ä½¿ç”¨å¿«é€Ÿæ¨¡å‹
                system_prompt="ä½ æ˜¯ä¸€ä¸ªæœç´¢è´¨é‡è¯„ä¼°ä¸“å®¶ï¼Œèƒ½å¿«é€Ÿåˆ¤æ–­æœç´¢ç»“æœçš„ç›¸å…³æ€§ã€‚"
            )
            return check_result

        except Exception as e:
            # å…œåº•ï¼šåŸºäºè§„åˆ™åˆ¤æ–­
            return QualityCheckResult(
                passed=True,  # ä¿å®ˆç­–ç•¥ï¼šä¸ç¡®å®šæ—¶é€šè¿‡
                score=0.7,
                issues=[f"è´¨é‡æ£€æŸ¥å¤±è´¥: {e}"],
                suggestions=["æ‰‹åŠ¨æ£€æŸ¥ç»“æœè´¨é‡"],
                action="continue"
            )

    @staticmethod
    def check_platform_balance(
        youtube_count: int,
        bilibili_count: int,
        target_ratio: float = 0.5
    ) -> QualityCheckResult:
        """
        æ£€æŸ¥å¹³å°åˆ†å¸ƒå¹³è¡¡æ€§

        Args:
            youtube_count: YouTubeæ•°æ®é‡
            bilibili_count: Bilibiliæ•°æ®é‡
            target_ratio: ç›®æ ‡æ¯”ä¾‹ï¼ˆé»˜è®¤0.5ï¼Œå³1:1ï¼‰

        Returns:
            QualityCheckResult
        """
        total = youtube_count + bilibili_count
        if total == 0:
            return QualityCheckResult(
                passed=False,
                score=0.0,
                issues=["æ²¡æœ‰æ”¶é›†åˆ°ä»»ä½•æ•°æ®"],
                suggestions=["æ£€æŸ¥æœç´¢è¯å’Œå·¥å…·é…ç½®"],
                action="retry"
            )

        youtube_ratio = youtube_count / total
        balance_score = 1 - abs(youtube_ratio - target_ratio) * 2  # 0-1

        passed = balance_score > 0.3  # å¹³è¡¡åº¦>30%æ‰é€šè¿‡

        issues = []
        suggestions = []

        if youtube_ratio < 0.2:
            issues.append(f"YouTubeæ•°æ®è¿‡å°‘ï¼ˆ{youtube_count}/{total}ï¼‰")
            suggestions.append("è¡¥å……YouTubeæœç´¢ä»»åŠ¡æˆ–é™ä½YouTubeç­›é€‰æ ‡å‡†")
        elif youtube_ratio > 0.8:
            issues.append(f"Bilibiliæ•°æ®è¿‡å°‘ï¼ˆ{bilibili_count}/{total}ï¼‰")
            suggestions.append("è¡¥å……Bilibiliæœç´¢ä»»åŠ¡æˆ–é™ä½Bilibiliç­›é€‰æ ‡å‡†")

        return QualityCheckResult(
            passed=passed,
            score=balance_score,
            issues=issues,
            suggestions=suggestions,
            action="adjust" if not passed else "continue"
        )

    @staticmethod
    def check_data_quantity(
        collected: int,
        target: int,
        min_acceptable: int = None
    ) -> QualityCheckResult:
        """
        æ£€æŸ¥æ•°æ®æ•°é‡æ˜¯å¦å……è¶³

        Args:
            collected: å·²æ”¶é›†æ•°é‡
            target: ç›®æ ‡æ•°é‡
            min_acceptable: æœ€å°å¯æ¥å—æ•°é‡

        Returns:
            QualityCheckResult
        """
        if min_acceptable is None:
            min_acceptable = int(target * 0.5)  # é»˜è®¤50%ä¸ºæœ€ä½çº¿

        if collected >= target:
            return QualityCheckResult(
                passed=True,
                score=1.0,
                issues=[],
                suggestions=[],
                action="continue"
            )

        if collected >= min_acceptable:
            return QualityCheckResult(
                passed=True,
                score=collected / target,
                issues=[f"æ•°æ®é‡ç•¥ä½äºç›®æ ‡ï¼ˆ{collected}/{target}ï¼‰"],
                suggestions=["å¯ä»¥ç»§ç»­ï¼Œä½†å»ºè®®è¡¥å……æ›´å¤šæ•°æ®"],
                action="continue"
            )

        return QualityCheckResult(
            passed=False,
            score=collected / target,
            issues=[f"æ•°æ®é‡ä¸¥é‡ä¸è¶³ï¼ˆ{collected}/{target}ï¼‰"],
            suggestions=["å¢åŠ æœç´¢ä»»åŠ¡", "æ”¾å®½ç­›é€‰æ¡ä»¶", "æ‰©å¤§æ—¶é—´èŒƒå›´"],
            action="adjust"
        )
```

---

### 2. Feedback Loop Manager (åé¦ˆå¾ªç¯ç®¡ç†å™¨)

**åŠŸèƒ½**: ç®¡ç†åé¦ˆå¾ªç¯ï¼Œé˜²æ­¢æ­»å¾ªç¯

**å®ç°**:
```python
# core/feedback_loop.py

from typing import Dict, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class LoopProtection:
    """å¾ªç¯ä¿æŠ¤é…ç½®"""
    max_retries: int = 3  # æœ€å¤§é‡è¯•æ¬¡æ•°
    max_adjustments: int = 2  # æœ€å¤§è°ƒæ•´æ¬¡æ•°
    retry_count: Dict[str, int] = field(default_factory=dict)  # æ¯ä¸ªä»»åŠ¡çš„é‡è¯•è®¡æ•°
    adjustment_count: Dict[str, int] = field(default_factory=dict)  # æ¯ä¸ªé˜¶æ®µçš„è°ƒæ•´è®¡æ•°

    def can_retry(self, task_id: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡è¯•"""
        return self.retry_count.get(task_id, 0) < self.max_retries

    def record_retry(self, task_id: str):
        """è®°å½•é‡è¯•"""
        self.retry_count[task_id] = self.retry_count.get(task_id, 0) + 1

    def can_adjust(self, phase: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥è°ƒæ•´"""
        return self.adjustment_count.get(phase, 0) < self.max_adjustments

    def record_adjustment(self, phase: str):
        """è®°å½•è°ƒæ•´"""
        self.adjustment_count[phase] = self.adjustment_count.get(phase, 0) + 1

    def reset(self):
        """é‡ç½®è®¡æ•°å™¨"""
        self.retry_count.clear()
        self.adjustment_count.clear()


class FeedbackLoopManager:
    """åé¦ˆå¾ªç¯ç®¡ç†å™¨"""

    def __init__(self):
        self.protection = LoopProtection()
        self.feedback_history = []  # åé¦ˆå†å²

    def process_quality_check(
        self,
        check_result: QualityCheckResult,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        å¤„ç†è´¨é‡æ£€æŸ¥ç»“æœï¼Œå†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨

        Args:
            check_result: è´¨é‡æ£€æŸ¥ç»“æœ
            context: å½“å‰ä¸Šä¸‹æ–‡ä¿¡æ¯

        Returns:
            è¡ŒåŠ¨å†³ç­–
        """
        phase = context.get("phase", "unknown")
        task_id = context.get("task_id", "unknown")

        # è®°å½•åé¦ˆå†å²
        self.feedback_history.append({
            "timestamp": datetime.now().isoformat(),
            "phase": phase,
            "task_id": task_id,
            "passed": check_result.passed,
            "score": check_result.score,
            "issues": check_result.issues,
            "action": check_result.action
        })

        # å¦‚æœé€šè¿‡ï¼Œç»§ç»­
        if check_result.passed:
            return {"action": "continue", "message": "è´¨é‡æ£€æŸ¥é€šè¿‡"}

        # å¦‚æœä¸é€šè¿‡ï¼Œæ ¹æ®å»ºè®®çš„actionå†³å®š
        if check_result.action == "retry":
            if not self.protection.can_retry(task_id):
                print(f"âš ï¸ ä»»åŠ¡ {task_id} å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒé‡è¯•")
                return {"action": "skip", "message": "å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°"}

            self.protection.record_retry(task_id)
            print(f"ğŸ”„ é‡è¯•ä»»åŠ¡ {task_id} (ç¬¬{self.protection.retry_count[task_id]}æ¬¡)")

            return {
                "action": "retry",
                "message": f"é‡è¯•ä»»åŠ¡ï¼ˆåŸå› : {', '.join(check_result.issues)}ï¼‰",
                "suggestions": check_result.suggestions
            }

        elif check_result.action == "adjust":
            if not self.protection.can_adjust(phase):
                print(f"âš ï¸ é˜¶æ®µ {phase} å·²è¾¾åˆ°æœ€å¤§è°ƒæ•´æ¬¡æ•°ï¼Œç»§ç»­æ‰§è¡Œ")
                return {"action": "continue", "message": "å·²è¾¾æœ€å¤§è°ƒæ•´æ¬¡æ•°ï¼Œç»§ç»­"}

            self.protection.record_adjustment(phase)
            print(f"âš™ï¸ è°ƒæ•´ç­–ç•¥ (é˜¶æ®µ: {phase}, ç¬¬{self.protection.adjustment_count[phase]}æ¬¡)")

            return {
                "action": "adjust",
                "message": f"è°ƒæ•´ç­–ç•¥ï¼ˆåŸå› : {', '.join(check_result.issues)}ï¼‰",
                "suggestions": check_result.suggestions
            }

        else:  # action == "continue" or unknown
            return {"action": "continue", "message": "ç»§ç»­æ‰§è¡Œ"}

    def get_feedback_summary(self) -> str:
        """è·å–åé¦ˆå†å²æ‘˜è¦"""
        if not self.feedback_history:
            return "æ— åé¦ˆè®°å½•"

        total = len(self.feedback_history)
        passed = sum(1 for f in self.feedback_history if f["passed"])
        retried = sum(1 for f in self.feedback_history if f["action"] == "retry")
        adjusted = sum(1 for f in self.feedback_history if f["action"] == "adjust")

        return f"åé¦ˆæ€»æ•°: {total}, é€šè¿‡: {passed}, é‡è¯•: {retried}, è°ƒæ•´: {adjusted}"
```

---

### 3. é›†æˆåˆ° Executor

**ä¿®æ”¹ `nodes/executor.py`ï¼Œå¢åŠ è´¨é‡é—¨æ£€æŸ¥**:

```python
# nodes/executor.py

from core.quality_gate import QualityGate
from core.feedback_loop import FeedbackLoopManager

# ğŸ”‘ æ–°å¢ï¼šå…¨å±€åé¦ˆå¾ªç¯ç®¡ç†å™¨
feedback_manager = FeedbackLoopManager()

def run_executor(state: RadarState) -> Dict[str, Any]:
    """æ‰§è¡Œå™¨ v2.0 - å¢åŠ è´¨é‡é—¨"""

    # ... ç°æœ‰ä»£ç  ...

    try:
        print(f"ğŸ”¨ æ‰§è¡Œ: {tool_name}...")

        # æ‰§è¡Œå·¥å…·
        result = tool_def.func(tool_args)
        print(f"âœ… ç»“æœ: {result.summary}")

        # ğŸ”‘ æ–°å¢ï¼šè´¨é‡é—¨æ£€æŸ¥
        if tool_name in ["youtube_search", "bilibili_search"]:
            quality_check = QualityGate.check_search_result(
                query=tool_args.get("keyword", ""),
                results=result.data if isinstance(result.data, list) else [],
                expectation=state.session_focus.get("priority_topics", ["æœªçŸ¥"])[0],
                min_items=10
            )

            print(f"ğŸ” è´¨é‡æ£€æŸ¥: å¾—åˆ† {quality_check.score:.2f}")

            if quality_check.issues:
                print(f"   âš ï¸ å‘ç°é—®é¢˜: {', '.join(quality_check.issues)}")

            if quality_check.suggestions:
                print(f"   ğŸ’¡ å»ºè®®: {', '.join(quality_check.suggestions)}")

            # å¤„ç†åé¦ˆ
            decision = feedback_manager.process_quality_check(
                check_result=quality_check,
                context={
                    "phase": "execution",
                    "task_id": f"{tool_name}:{tool_args.get('keyword', '')}",
                    "tool_name": tool_name,
                    "tool_args": tool_args
                }
            )

            # ğŸ”‘ æ ¹æ®å†³ç­–è¡ŒåŠ¨
            if decision["action"] == "retry":
                # é‡æ–°ç”Ÿæˆæœç´¢è¯
                print(f"ğŸ”„ å‡†å¤‡é‡è¯•...")
                # å¯ä»¥è°ƒç”¨ keyword_designer é‡æ–°ç”Ÿæˆæœç´¢è¯
                # æˆ–è€…è°ƒæ•´å‚æ•°åé‡è¯•

            elif decision["action"] == "adjust":
                # è°ƒæ•´å‚æ•°
                print(f"âš™ï¸ è°ƒæ•´å‚æ•°...")
                if "å¢åŠ æŠ“å–æ•°é‡" in quality_check.suggestions:
                    if tool_name == "bilibili_search":
                        tool_args["fetch_size"] = tool_args.get("fetch_size", 100) * 2
                        print(f"   å¢åŠ  fetch_size åˆ° {tool_args['fetch_size']}")

        # ... ç°æœ‰æ•°æ®å¤„ç†ä»£ç  ...

        # ğŸ”‘ æ–°å¢ï¼šæ£€æŸ¥å¹³å°å¹³è¡¡
        youtube_count = len([c for c in state.candidates if c.platform == "youtube"])
        bilibili_count = len([c for c in state.candidates if c.platform == "bilibili"])

        balance_check = QualityGate.check_platform_balance(
            youtube_count=youtube_count,
            bilibili_count=bilibili_count
        )

        if not balance_check.passed:
            print(f"âš–ï¸ å¹³å°å¹³è¡¡æ£€æŸ¥: {', '.join(balance_check.issues)}")
            # å¯ä»¥è‡ªåŠ¨è¡¥å……ä»»åŠ¡

        return {
            "plan_status": "planning",
            # ... ç°æœ‰è¿”å› ...
        }

    except Exception as e:
        # ... å¼‚å¸¸å¤„ç† ...
```

---

## ğŸ¯ å…³é”®è®¾è®¡åŸåˆ™

### 1. **å¿«é€Ÿæ¨¡å‹ä¼˜å…ˆ** (Cost-Efficient)
```python
# è´¨é‡æ£€æŸ¥ç”¨haikuï¼ˆå¿«é€Ÿ+ä¾¿å®œï¼‰
quality_check = get_llm_with_schema(
    capability="fast",  # ä½¿ç”¨haiku
    ...
)

# åªåœ¨å…³é”®å†³ç­–æ—¶ç”¨sonnet
final_decision = get_llm_with_schema(
    capability="reasoning",  # ä½¿ç”¨sonnet
    ...
)
```

### 2. **æ­»å¾ªç¯ä¿æŠ¤** (Loop Protection)
```python
class LoopProtection:
    max_retries: int = 3      # æ¯ä¸ªä»»åŠ¡æœ€å¤šé‡è¯•3æ¬¡
    max_adjustments: int = 2  # æ¯ä¸ªé˜¶æ®µæœ€å¤šè°ƒæ•´2æ¬¡

# è¶…è¿‡é™åˆ¶åï¼Œå¼ºåˆ¶ç»§ç»­æˆ–è·³è¿‡
```

### 3. **æ¸è¿›å¼è°ƒæ•´** (Progressive Adjustment)
```
ç¬¬1æ¬¡é—®é¢˜ â†’ å°è°ƒæ•´ï¼ˆå¦‚ä¿®æ”¹æœç´¢è¯ä¸­çš„ä¸€ä¸ªå…³é”®è¯ï¼‰
ç¬¬2æ¬¡é—®é¢˜ â†’ ä¸­è°ƒæ•´ï¼ˆå¦‚æ›´æ¢æœç´¢ç­–ç•¥ï¼‰
ç¬¬3æ¬¡é—®é¢˜ â†’ å¤§è°ƒæ•´ï¼ˆå¦‚æ”¾å¼ƒè¯¥è·¯çº¿ï¼Œå°è¯•å®Œå…¨ä¸åŒçš„æ–¹æ³•ï¼‰
```

### 4. **åé¦ˆå†å²è¿½è¸ª** (Feedback History)
```python
self.feedback_history = [
    {
        "timestamp": "2025-01-15T10:30:00",
        "phase": "execution",
        "task_id": "youtube_search:AI short drama",
        "passed": False,
        "score": 0.3,
        "issues": ["æœç´¢ç»“æœä¸ç›¸å…³"],
        "action": "retry"
    },
    # ...
]

# å¯ä»¥åˆ†æè¶‹åŠ¿ï¼Œé¿å…é‡å¤é”™è¯¯
```

---

## ğŸ“Š æ•ˆæœé¢„æœŸ

### ä¼˜åŒ–å‰ï¼ˆæ— åé¦ˆå¾ªç¯ï¼‰
```
Plan â†’ Execute â†’ Filter â†’ Output
  â†“       â†“        â†“       â†“
ç”Ÿæˆè¯   æœç´¢     ç­›é€‰    ç»“æŸ
        è¿”å›     15æ¡    10æ¡
        iPad     ä¸­3æ¡
        è§†é¢‘     ç›¸å…³

é—®é¢˜: å‘ç°è´¨é‡å·®ä¹Ÿæ— æ³•ä¿®æ­£
```

### ä¼˜åŒ–åï¼ˆæœ‰åé¦ˆå¾ªç¯ï¼‰
```
Plan â†’ Execute â†’ Quality Check â†’ Adjust â†’ Re-Execute
  â†“       â†“          â†“            â†“         â†“
ç”Ÿæˆè¯   æœç´¢     å‘ç°é—®é¢˜      ä¿®æ”¹è¯    é‡æ–°æœç´¢
        è¿”å›     (iPadè§†é¢‘)    å»æ‰     è¿”å›
        15æ¡     ç›¸å…³æ€§0.2    "short"   30æ¡
                                        ä¸­25æ¡
                                        ç›¸å…³

ç»“æœ: è‡ªåŠ¨ä¿®æ­£ï¼Œè´¨é‡æå‡
```

---

## ğŸš€ å®æ–½ä¼˜å…ˆçº§

### Phase 1: æ ¸å¿ƒè´¨é‡é—¨ï¼ˆæœ¬å‘¨ï¼‰
- [x] QualityGateåŸºç¡€ç±»
- [ ] æœç´¢ç»“æœè´¨é‡æ£€æŸ¥
- [ ] é›†æˆåˆ°Executor

### Phase 2: åé¦ˆå¾ªç¯ï¼ˆä¸‹å‘¨ï¼‰
- [ ] FeedbackLoopManager
- [ ] æ­»å¾ªç¯ä¿æŠ¤
- [ ] è‡ªåŠ¨è°ƒæ•´ç­–ç•¥

### Phase 3: æ™ºèƒ½åŒ–å¢å¼ºï¼ˆæœªæ¥ï¼‰
- [ ] å­¦ä¹ å†å²åé¦ˆï¼Œä¼˜åŒ–å†³ç­–
- [ ] A/Bæµ‹è¯•ä¸åŒç­–ç•¥
- [ ] è‡ªåŠ¨ç”Ÿæˆæœ€ä½³å®è·µ

---

## ğŸ’¡ æˆæœ¬æ§åˆ¶

| ç»„ä»¶ | æ¨¡å‹ | æˆæœ¬ | é¢‘ç‡ |
|------|------|------|------|
| è´¨é‡æ£€æŸ¥ | haiku | æä½ | æ¯æ¬¡æ‰§è¡Œå |
| æœç´¢è¯é‡ç”Ÿæˆ | haiku | ä½ | ä»…åœ¨å¤±è´¥æ—¶ |
| æœ€ç»ˆå†³ç­– | sonnet | ä¸­ | ä»…å…³é”®å†³ç­– |

**é¢„æœŸæˆæœ¬å¢åŠ **: <10%ï¼ˆå¤§éƒ¨åˆ†ç”¨haikuï¼‰
**è´¨é‡æå‡**: 50%+ï¼ˆè‡ªåŠ¨ä¿®æ­£é—®é¢˜ï¼‰

---

è¿™å°±æ˜¯ä¸€ä¸ªå®Œæ•´çš„**è‡ªé€‚åº”åé¦ˆå¾ªç¯ç³»ç»Ÿ**ï¼å®ƒè®©Agentåœ¨æ¯ä¸ªé˜¶æ®µéƒ½èƒ½"æ€è€ƒ-åé¦ˆ-è°ƒæ•´"ï¼Œè€Œä¸æ˜¯ç›²ç›®æ‰§è¡Œã€‚
